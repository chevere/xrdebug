#!/usr/bin/env php
<?php

/*
 * This file is part of Chevere.
 *
 * (c) Rodolfo Berrios <rodolfo@chevere.org>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

declare(strict_types=1);

use Chevere\Filesystem\File;
use Chevere\Router\Dependencies;
use Chevere\Router\Dispatcher;
use Chevere\xrDebug\Build;
use Chevere\xrDebug\Debugger;
use Clue\React\Sse\BufferedChannel;
use Colors\Color;
use Psr\Http\Message\ServerRequestInterface;
use React\EventLoop\Loop;
use React\Http\HttpServer;
use React\Http\Middleware\LimitConcurrentRequestsMiddleware;
use React\Http\Middleware\RequestBodyBufferMiddleware;
use React\Http\Middleware\RequestBodyParserMiddleware;
use React\Http\Middleware\StreamingRequestMiddleware;
use React\Socket\SocketServer;
use React\Stream\ThroughStream;
use samejack\PHP\ArgvParser;
use function Chevere\Filesystem\directoryForPath;
use function Chevere\ThrowableHandler\handleAsTerminal;
use function Chevere\Writer\writers;
use function Chevere\xrDebug\getCipher;
use function Chevere\xrDebug\getPrivateKey;
use function Chevere\xrDebug\getResponse;

require_once __DIR__ . '/loader.php';
$color = new Color();
$logo = (new File($appDirectory->path()->getChild('logo')))->getContents();
$logger = writers()->log();
$logger->write(
    $color($logo)->cyan()
    . "\n"
    . $color(strtr('xrDebug %v (%c) by Rodolfo Berrios', [
        '%v' => XRDEBUG_VERSION,
        '%c' => XRDEBUG_CODENAME,
    ]))->green()
    . "\n\n"
);
$options = (new ArgvParser())->parseConfigs();
if (array_key_exists('h', $options) || array_key_exists('help', $options)) {
    $logger->write(
        <<<LOG
        -p Port (default 27420)
        -n Session name (default xrDebug)
        -e Enable end-to-end encryption
        -v Enable sign verification
        -c Cert file for TLS
        -w Working directory
        -k [for -e option] Symmetric key
        -s [for -v option] Private key
        -i Editor (default vscode)
            [for -i option] Supported IDEs:
            atom emacs espresso idea macvim netbeans
            phpstorm sublime textmate vscode

        LOG
    );
    exit(0);
}
$host = '127.0.0.1';
$port = $options['p'] ?? '27420';
$sessionName = $options['n'] ?? 'xrDebug';
$cert = $options['c'] ?? null;
$isEncryptionEnabled = $options['e'] ?? false;
$isSignVerificationEnabled = $options['v'] ?? false;
$scheme = isset($cert) ? 'tls' : 'tcp';
$editor = $options['i'] ?? 'vscode';
$uri = "{$scheme}://{$host}:{$port}";
$context = $scheme === 'tcp'
    ? []
    : [
        'tls' => [
            'local_cert' => $cert,
        ],
    ];
$workingDirectory = realpath($options['w'] ?? sys_get_temp_dir());
if (! $workingDirectory) {
    $logger->write(
        $color("[ERROR] Working directory doesn't exists.")->red() . "\n"
    );
    exit(1);
}
$workingDirectory = directoryForPath($workingDirectory);
$cipher = null;
if ($isEncryptionEnabled) {
    $symmetricKey = $options['k'] ?? null;
    if ($symmetricKey === true) {
        $symmetricKey = null;
    }
    $cipher = getCipher($symmetricKey, $logger, $color);
}
$privateKey = null;
if ($isSignVerificationEnabled) {
    $privateKey = $options['s'] ?? null;
    if ($privateKey === true) {
        $privateKey = null;
    }
    $privateKey = getPrivateKey($privateKey, $logger, $color);
}
$locksDirectory = $workingDirectory->getChild('locks/');
$appCompiledPath = $workingDirectory->getChild('app/compiled/')->path();

try {
    $locksDirectory->removeContents();
} catch (Throwable) {
}
$build = new Build(
    source: $appDirectory->getChild('src/'),
    version: XRDEBUG_VERSION,
    codename: XRDEBUG_CODENAME,
    sessionName: $sessionName,
    editor: $editor,
    isEncryptionEnabled: $isEncryptionEnabled,
    isSignVerificationEnabled: $isSignVerificationEnabled
);
$app = new File($appCompiledPath->getChild('en.html'));
$app->removeIfExists();
$app->create();
$app->put($build->__toString());
$dependencies = new Dependencies($routes);
$dispatcher = new Dispatcher($routeCollector);
$loop = Loop::get();
$channel = new BufferedChannel();
$debugger = new Debugger($channel, $logger, $cipher);
$containerMap = [
    'app' => $app,
    'channel' => $channel,
    'cipher' => $cipher,
    'debugger' => $debugger,
    'directory' => $locksDirectory,
    'logger' => $logger,
    'loop' => $loop,
    'privateKey' => $privateKey,
    'stream' => new ThroughStream(),
];
$handler = function (ServerRequestInterface $request) use ($dispatcher, $dependencies, $containerMap) {
    try {
        return getResponse($request, $dispatcher, $dependencies, $containerMap);
    } catch (Throwable $e) {
        handleAsTerminal($e);
    }
};
$http = new HttpServer(
    $loop,
    new StreamingRequestMiddleware(),
    new LimitConcurrentRequestsMiddleware(100),
    new RequestBodyBufferMiddleware(8 * 1024 * 1024),
    new RequestBodyParserMiddleware(100 * 1024, 1),
    $handler
);
$socket = new SocketServer($uri, $context, $loop);
$http->listen($socket);
$socket->on('error', 'printf');
$scheme = parse_url($socket->getAddress(), PHP_URL_SCHEME);
$httpAddress = strtr(
    $socket->getAddress(),
    [
        'tls' => 'https',
        'tcp' => 'http',
    ]
);
$logger->write(
    <<<LOG
    Server listening on {$scheme} {$httpAddress}
    Press Ctrl+C to quit
    --

    LOG
);
$loop->run();
